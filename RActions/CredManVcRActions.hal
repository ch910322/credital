external inner procedure CredManVc_PasteType(var record CredManVc);
external inner procedure CUCreditLimit(record CUVc,Date,string,var val,var LongInt);
external function val GetMonthlyPaymentAmount(record CredManVc,Integer);


global
function LongInt CredManVcRecordDefaults(var record CredManVc CredManr,record CredManVc CredMan2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record BaseCurBlock BCb;
  record CredManSetBlock CMb;

  BlockLoad(BCb);
  BlockLoad(CMb);
  CredManr.CurncyCode = BCb.BaseCur1;
  CredManr.MonthlyPaymentDay = CMb.InvDay;

  res = inner.CredManVcRecordDefaults(CredManr,CredMan2r,stat,long4);
  CredManVc_PasteType(CredManr);
  
  CredManVcRecordDefaults = res;
  return;
END;

global
function LongInt CredManVcRecordDuplicate(var record CredManVc CredManr,record CredManVc CredMan2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record BaseCurBlock BCb;
  record CredManSetBlock CMb;
  val t;

  BlockLoad(BCb);
  BlockLoad(CMb);
  CredManr.CurncyCode = BCb.BaseCur1;
  CredManr.MonthlyPaymentDay = CMb.InvDay;
/*
  CredManr.FactInvAmount = t;
  CredManr.LoanToValue = t;
  CredManr.FactBuyer = "";
  CredManr.FactBuyerName = "";
  CredManr.FactInvNumber = "";
  CredManr.FactComment = "";
  CredManr.FactInsured = 0;
*/

  res = inner.CredManVcRecordDefaults(CredManr,CredMan2r,stat,long4);
  
  CredManVcRecordDuplicate = res;
  return;
END;

function val GetFactoringTotalAgreementWorth(string cucode,Date enddate,Longint sernr)
begin
  record CredManVc CredManr;
  Boolean TrHs;
  val res;

  TrHs = true;
  CredManr.FactBuyer = cucode;
  CredManr.endDate = CurrentDate;
  while (LoopKey("FactBuyer",CredManr,2,TrHs)) begin
    if (CredManr.FactBuyer!=cucode ) then begin//or CredManr.endDate>enddate?
      TrHs = false;
    end else begin
      if (CredManr.startDate<=CurrentDate and CredManr.InstalmentType==4) then begin
        if (CredManr.SerNr!=sernr) then begin
          res = res + CredManr.FactInvAmount;
        end;
      end;
    end;
  end;
  
  GetFactoringTotalAgreementWorth = res;
  return;
end;

global
function LongInt CredManVcRecordCheck(var record CredManVc CredManr,record CredManVc CredMan2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record CredManVc tCredManr;
  Boolean TrHs,credf;
  Longint crlimitdays;
  val crlimit,totworth;
  record CUVc CUr;
  record CredManFactVc CMFr;

  res = 0;

  if (CredManr.InstalmentType==4) then begin
/*
    if (CredManr.FactInvAmount<=0) then begin
      RecordCheckError(1058,"",-1,"FactInvAmount");
      res = -1;
      goto LCredManVcRecordCheck;
    end;
    if (blank(CredManr.FactInvNumber)) then begin
      RecordCheckError(1058,"",-1,"FactInvNumber");
      res = -1;
      goto LCredManVcRecordCheck;
    end else begin
      TrHs = true;
      tCredManr.FactInvNumber = CredManr.FactInvNumber;
      while (LoopKey("FactInvNumber",tCredManr,1,TrHs)) begin
        if (tCredManr.FactInvNumber!=CredManr.FactInvNumber) then begin
          TrHs = false;
        end else begin
          if (tCredManr.SerNr!=CredManr.SerNr) then begin
            RecordCheckError(200100,"",-1,"FactInvNumber");
            res = -1;
            goto LCredManVcRecordCheck;
          end;
        end;
      end;
    end;
  */
    CMFr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CMFr,1,true)) then begin
      if (CMFr.Total>CredManr.InvSum4) then begin
        RecordCheckError(200101,"",-1,"InvSum4");
        res = -1;
        goto LCredManVcRecordCheck;
      end;
    end;
  end;

  if (CredManr.MonthlyPaymentDay<=0) then begin
    RecordCheckError(1058,"",-1,"MonthlyPaymentDay");
    res = -1;
    goto LCredManVcRecordCheck;
  end;

  if (CredManr.InstalmentType==6) then begin
    if (CredManr.PrincipleDelayMonths<=0) then begin
      RecordCheckError(1058,"",-1,"PrincipleDelayMonths");
      res = -1;
      goto LCredManVcRecordCheck;
    end;
    if (CredManr.PrincipleDelayInterest<=0) then begin
      RecordCheckError(1058,"",-1,"PrincipleDelayInterest");
      res = -1;
      goto LCredManVcRecordCheck;
    end;
  end;
  if (CredManr.MaxMonthlyPayment>0) then begin
    if (CredManr.MaxMonthlyPayment<GetMonthlyPaymentAmount(CredManr,6)) then begin
      RecordCheckError(200105,"",-1,"MaxMonthlyPayment");
      res = -1;
      goto LCredManVcRecordCheck;
    end;
  end;

  res = inner.CredManVcRecordCheck(CredManr,CredMan2r,stat,long4);
  
LCredManVcRecordCheck:;
  CredManVcRecordCheck = res;
  return;
END;

global
function val GetCustomerOpenInvoices(string custcode)
begin
  record ARVc ARr;
  val res;
  Boolean TrHs;

  TrHs = true;
  ARr.CustCode = custcode;
  while (LoopKey("CustCode",ARr,1,TrHs)) begin
    if (ARr.CustCode!=custcode) then begin
      TrHs = false;
    end else begin
      res = res + ARr.RVal;
    end;
  end;

  GetCustomerOpenInvoices = res;
  return;
end;

global
function LongInt CredManFactVcRecordCheck(var record CredManFactVc CMFr,record CredManFactVc CMF2r,LongInt stat,LongInt long4)
begin
  Longint res;
  record CredManVc CredManr;
  row CredManFactVc CMFrw;
  Integer i,rwcnt;
  val openval;

  res = 0;
  
  CredManr.SerNr = CMFr.CredManNr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    if (CMFr.Total>CredManr.InvSum4) then begin
      RecordCheckError(200101,"",-1,"Total");
      res = -1;
      goto LCredManFactVcRecordCheck;
    end;
  end;
  rwcnt = MatRowCnt(CMFr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CMFr,i,CMFrw);
    openval = GetCustomerOpenInvoices(CMFrw.CustCode);
    if (openval>CMFrw.MaxLimit) then begin
      RecordCheckError(200104,openval,i,"MaxLimit");
      res = -1;
      goto LCredManFactVcRecordCheck;
    end;
  end;

LCredManFactVcRecordCheck:;
  CredManFactVcRecordCheck = res;
  return;
end;
