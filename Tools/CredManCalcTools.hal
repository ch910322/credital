external inner function val GetCredManRate(Integer,string,val,Date);
external inner function LongInt DateDiff(Date,Date);
external inner function roundmode SetRoundModeD(Integer);
external inner function LongInt MonthDiff(Date,Date);

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

//This is used to get correct amounts (fees and interest) for first and last months (as they need to be different)
enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

procedure CalcCredManCurrentPeriod(record CredManVc CredManr,Integer paymentnr,var Date sdp,var Date edp,var Date invd)
begin

  if (paymentnr==-1) then begin
    sdp = CredManr.startDate;
    edp = AddDay(CredManr.FirstInvDate,-1);
    invd = CredManr.FirstInvDate;
  end else begin
    sdp = AddMonth(CredManr.startDate,paymentnr);
    if (nonblankdate(CredManr.FirstInvDate)) then begin
      sdp = AddMonth(CredManr.FirstInvDate,paymentnr); //  - 1
    end;
    edp = AddDay(AddMonth(sdp,1),-1);
    invd = AddMonth(sdp,1);
  end;
  return;
end;

function val GetAmount(record CredManVc CredManr)
begin
  val res;

  res = CredManr.InvSum4 - CredManr.DepositSum;
  
  GetAmount = res;
  return;
end;

function val GetRateAmount(record CredManVc CredManr,val rate,Integer monthtypef,Date frdate,Date todate,val calcbal)
begin
  record CMApplicationSetBlock CMb;
  val days,res;

  switch (monthtypef) begin
    case kMonthTypeFirst:
      BlockLoad(CMb);
      days = DateDiff(todate,frdate);
      res = GetAmount(CredManr)*(rate/100)*12/CMb.DaysInYear*days;
    case kMonthTypeRegular:
      res = GetAmount(CredManr)*(rate/100);    
    case kMonthTypeLast:
      res = calcbal*(rate/100);    
  end;

  GetRateAmount = res;
  return;
end;

function Boolean MonthlyChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==1 or chargetype==3) then begin
    res = true;
  end;
  
  MonthlyChargeType = res;
  return;
end;

function Boolean CalculatedChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==2 or chargetype==3) then begin
    res = true;
  end;
  
  CalculatedChargeType = res;
  return;
end;

function Boolean TypeAffectsBalance(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInstalment:  res = true;
    case kEventTypeIssueInstalment: res = true;
    case kEventTypeIssueDeposit:    res = true;
    case kEventTypeCalcDeposit:     res = true;
  end;
  
  TypeAffectsBalance = res;
  return;
end;

function Boolean TypeAffectsInterest(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInterest:  res = true;
    case kEventTypeIssueInterest: res = true;
  end;
  
  TypeAffectsInterest = res;
  return;
end;

procedure AddCredPayPlanLine(record CredManPayPlanVc CredManPayPlanr,Date transdate,string item,string itemname,Integer type,val sum,val reb,var val acumint,var val calcbal,Date frdate,Date todate,Longint histnr)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = Round(sum,SetRoundModeD(2));//round(sum,SetRoundModeD(rounding));//CredManr.DepositSum,CredManSetb.DepositRoundOff
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = item;
    CredManPayPlanrw.Spec = itemname;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = type;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.Reb = reb;
    CredManPayPlanrw.FromDate = frdate;
    CredManPayPlanrw.ToDate = todate;
    CredManPayPlanrw.IssuedNr = histnr;
    if (TypeAffectsInterest(type)) then begin
      CredManPayPlanrw.AcumulatedInt = acumint + v;
    end else begin
      CredManPayPlanrw.AcumulatedInt = acumint;
    end;
    if (TypeAffectsBalance(type)) then begin
      CredManPayPlanrw.Bal = calcbal - v;
    end else begin
      CredManPayPlanrw.Bal = calcbal;
    end;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;

  return;
end;

global
procedure AddInterest(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin

  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.IntRate,monthtypef,frdate,todate,calcbal),0,acumint,calcbal,frdate,todate,-1);

  return;
end;

global
procedure AddPlannedFees(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer type,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  Integer i,rwcnt;
  row CredManVc CredManrw;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if ((type==kPlannedFeesMonthly and MonthlyChargeType(CredManrw.ChargeType)) or 
        (type==kPlannedFeesOneTime and MonthlyChargeType(CredManrw.ChargeType)==false)) then begin
      if (CalculatedChargeType(CredManrw.ChargeType)) then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CredManrw.ArtCode,"",kEventTypeCalcFees,GetRateAmount(CredManr,CredManrw.vRebate,monthtypef,frdate,todate,calcbal),0,acumint,calcbal,frdate,todate,-1);
      end else begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CredManrw.ArtCode,"",kEventTypeCalcFees,CredManrw.Price,CredManrw.vRebate,acumint,calcbal,frdate,todate,-1);
      end;
    end;
  end;
  
  return;
end;

procedure AddDeposit(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.DepositItem,"",kEventTypeCalcDeposit,CredManr.DepositSum,0,acumint,calcbal,frdate,todate,-1);

  return;
end;

procedure AddInstalment(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Boolean linearf,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  if (linearf) then begin
    logtext(0,"invdate " & invdate & ",monthtypef=" & monthtypef & ",calcbal=" & calcbal);
    if (monthtypef==kMonthTypeLast) then begin
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1);
    end else begin
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,(CredManr.InvSum4-CredManr.DepositSum)/CredManr.InstalmentMonths,0,acumint,calcbal,frdate,todate,-1);
    end;
  end else begin
    AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,CredManr.InvSum4,0,acumint,calcbal,frdate,todate,-1);
  end;
     logtext(0,"xxxx - invdate " & invdate & ",monthtypef=" & monthtypef & ",calcbal=" & calcbal);
 return;
end;

global
procedure AddInstalmentFixed(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,val amount,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,amount,0,acumint,calcbal,frdate,todate,-1);

  return;
end;

function Integer GetCredHistType(string artcode,Boolean paidflag)
begin
  record CredManSetBlock CMSb;
  Integer res;

  res = 0;
  BlockLoad(CMSb);
  if (artcode==CMSb.InstalmentItem) then begin
    if (paidflag) then begin
      res = kEventTypeIssueInstalment;
    end else begin
      res = kEventTypeCalcInstalment;
    end;
  end else begin
    if (artcode==CMSb.RateItem) then begin
      if (paidflag) then begin
        res = kEventTypeIssueInterest;
      end else begin
        res = kEventTypeCalcInterest;
      end;
    end else begin
      if (artcode==CMSb.DepositItem) then begin
        if (paidflag) then begin
          res = kEventTypeIssueDeposit;
        end else begin
          res = kEventTypeCalcDeposit;
        end;
      end else begin
        if (paidflag) then begin
          res = kEventTypeIssueFees;
        end else begin
          res = kEventTypeCalcFees;
        end;
      end;
    end;
  end;

  GetCredHistType = res;
  return;
end;

function Boolean IsInitialInvoice(record CredManVc CredManr,Date transdate,Longint lastrecnr,Boolean firstinvf)
begin
  Boolean res;

  if (CredManr.startDate==transdate) then begin
    if (lastrecnr==-1 or firstinvf) then begin
      res = true;
    end;
  end;
  
  IsInitialInvoice = res;
  return;
end;

procedure AddActualsToPlan(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,var Integer calculatedmonths,var val acumint,var val calcbal,var Boolean firstinvf)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  Integer type;
  Longint lastrecnr;
  vector Boolean vFirstInv;

  firstinvf = false;
  calculatedmonths = 0;
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      type = GetCredHistType(CredHistr.ArtCode,true);
      AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,CredHistr.ArtCode,"",type,CredHistr.Sum,0,acumint,calcbal,"","",CredHistr.SerNr);
      if (IsInitialInvoice(CredManr,CredHistr.TransDate,lastrecnr,vFirstInv[CredHistr.RecordNr])) then begin
        firstinvf = true;
        vFirstInv[CredHistr.RecordNr] = true;//we can have multiple records for single invoice. so we need to store that this invoice is the initial invoice
      end else begin
        if (CredHistr.RecordType==0) then begin//invoice
          calculatedmonths = MonthDiff(CredManr.FirstInvDate,CredHistr.TransDate)+1;
        end;
      end;
      lastrecnr = CredHistr.RecordNr;
    end;
  end;

  return;
end;

procedure AddInitialInvoice(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddPlannedFees(CredManr,CredManPayPlanr,CMb,kPlannedFeesOneTime,kMonthTypeFirst,CredManr.startDate,acumint,calcbal,frdate,todate);

  return;
end;

function Boolean CredManIsPaused(record CredManVc CredManr,Date invdate)
begin
  Boolean res;
  Date pstart,pend;

  if (nonblank(CredManr.PauseDate)) then begin
    pstart = CredManr.PauseDate;
    pend = AddDay(AddMonth(pstart,CredManr.PauseMonths),-1);
    if (DateInRange(invdate,pstart,pend)) then begin
      res = true;
    end;
  end;

  CredManIsPaused = res;
  return;
end;

function Integer GetMonthType(Integer month,Integer totmonths)
begin
  Integer res;

  res = kMonthTypeRegular;
  if (month==0) then begin
    res = kMonthTypeFirst;
  end;
  if (month==totmonths-1) then begin
    res = kMonthTypeLast;
  end;

  GetMonthType = res;
  return;
end;

global
procedure BuildCredManPayPlanCust(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean suggestedonsameday)
begin
  Integer calculatedmonths,months;
  val acumint,calcbal;
  Integer i,monthtype;
  val hundred,twelve;
  Date invdat,frdat,todat;
  Boolean firstinvf;
  
/*should we calculate VAT here?
  if CredManr.VATSum > 0 and nonblank(CredManr.VATAddMonths) then begin
    GetMonthlyVatVector(CredManr.VATSum, CredManr.VATAddMonths, vatPayments);
  end;
*/

  hundred = 100;
  twelve = 12;

  months = inCredManr.InstalmentMonths;
  if (nonblank(inCredManr.PauseDate)) then begin
    months = months + inCredManr.PauseMonths;
  end;
  acumint = 0;
  calcbal = inCredManr.InvSum4;

  if (withactuals) then begin
    AddActualsToPlan(inCredManr,CredManPayPlanr,calculatedmonths,acumint,calcbal,firstinvf);
  end;
  
  for(i=calculatedmonths;i<months;i=i+1) begin
    if (calcbal>0) then begin
      CalcCredManCurrentPeriod(inCredManr,i-1,frdat,todat,invdat); //sets dates, frdat, todat and invdat
      if (i==0 and firstinvf==false) then begin
        AddInitialInvoice(inCredManr,CredManPayPlanr,CredManSetb,acumint,calcbal,"","");
      end;
      monthtype = GetMonthType(i,months);
      switch (inCredManr.InstalmentType) begin
        case 0://Annuity
        case 1://Linear
        case 2://Linear with Service Fee - bullet with linear or just Same, Same
          if (CredManIsPaused(inCredManr,invdat)==false) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,true,monthtype,invdat,acumint,calcbal,frdat,todat);
          end;
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype,invdat,acumint,calcbal,frdat,todat);
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype,invdat,acumint,calcbal,frdat,todat);
        case 3://Bullet
          if (i==months-1) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,false,monthtype,invdat,acumint,calcbal,frdat,todat)
          end;
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype,invdat,acumint,calcbal,frdat,todat);
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype,invdat,acumint,calcbal,frdat,todat);
        case 4://Factoring
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeRegular,invdat,acumint,calcbal,frdat,todat);
          AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,false,kMonthTypeRegular,invdat,acumint,calcbal,frdat,todat);
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,kMonthTypeRegular,invdat,acumint,calcbal,frdat,todat);
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesOneTime,kMonthTypeRegular,invdat,acumint,calcbal,frdat,todat);
        //case 5://Payment Guarantee

      end;
      if (i==0) then begin
        AddDeposit(inCredManr,CredManPayPlanr,CredManSetb,invdat,acumint,calcbal,frdat,todat);
      end;
    end;
  end;

  return;
end;

global
function string 255 GetPlanTypeTextCust(Integer plantype)
begin
  string 255 res;
  
  switch (plantype) begin
    case 0: res = "Should not happen";
    case 1: res = "Suggested Instalment";
    case 2: res = "Suggested Interest";
    case 3: res = "Suggested Deposit";
    case 4: res = "Suggested Fee";
    case 5: res = "Invoiced Instalment";
    case 6: res = "Invoiced Interest";
    case 7: res = "Invoiced Deposit";
    case 8: res = "Invoiced Fee";
    case 9: res = "Invoiced Late Fees";
    case 10: res = "Paid Instalment";
    case 11: res = "Paid Interest";
    case 12: res = "Paid Deposit";
    case 13: res = "Paid Fee";
  end;
  GetPlanTypeTextCust = res;
  return;
end;
