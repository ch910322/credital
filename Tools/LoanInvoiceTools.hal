remote inner function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
remote inner procedure IVVc_PastePayDeal(var record IVVc,string,string);
remote inner procedure IVVc_PasteSalesMan(var record IVVc,string);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner procedure IVDchsum(var record IVVc,Integer);
external inner procedure IVVc_PastePrice(var record IVVc,record IVVc,Integer,var string);
external inner function LongInt DateDiff(Date,Date);


enum begin
  kCredHistRecTypeInvoice = 0,
  kCredHistRecTypeReceipt = 1
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

enum begin
  kChargeTypeInstalment = 1,
  kChargeTypeDeposit = 2,
  kChargeTypeInterest = 3,
  kChargeTypeLateFees = 4,
  kChargeTypePlannedFees = 5
end;

procedure SetupLoanInvoice(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate)
begin
  record LocalMachineBlock LMb;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  row IVVc IVrw;
  record CMApplicationSetBlock CMASb;
  
  BlockLoad(LMb);
  BlockLoad(CMASb);

  RecordNew(IVr);
  IVr.CustCredManNr = CredManr.SerNr;
  IVr.TransDate = invdate;//or current date?
  IVr.InvDate = invdate;//from seting?

  IVr.CustCode = CredManr.CustCode;
  PasteCust2InInv(IVr,LMb,"",true,warning,errstr,prepstr,invdatewarn,transdatewarn);
  IVr.PayDeal = CredManr.PayDeal;
  IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  IVr.SalesMan = CredManr.SalesMan;
  IVVc_PasteSalesMan(IVr,""); 

  if (CMASb.DetailedInvoice==1) then begin
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = USetStr(200080) & CredManr.SerNr;
    MatRowPut(IVr,0,IVrw);
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = USetStr(200081) & invdate & ":" & AddDay(AddMonth(invdate,1),-1);
    MatRowPut(IVr,1,IVrw);
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = " ";
    MatRowPut(IVr,2,IVrw);
  end;

  IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");

  return;
end;

function val GetAmount(record CredManVc CredManr)
begin
  val res;

  res = CredManr.InvSum4 - CredManr.DepositSum;
  
  GetAmount = res;
  return;
end;

function val GetRateAmount(record CredManVc CredManr,val rate)
begin
  val res;

  res = GetAmount(CredManr)*(rate/100);

  GetRateAmount = res;
  return;
end;

function val GetRateAmount2(record CredManVc CredManr,val rate)
begin
  record CMApplicationSetBlock CMb;
  val days,res;

  BlockLoad(CMb);

  days = DateDiff(CredManr.FirstInvDate,CredManr.startDate);

  res = GetAmount(CredManr)*(rate/100)*12/CMb.DaysInYear*days;

  GetRateAmount2 = res;
  return;
end;

function Boolean MonthlyChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==1 or chargetype==3) then begin
    res = true;
  end;
  
  MonthlyChargeType = res;
  return;
end;

function Boolean CalculatedChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==2 or chargetype==3) then begin
    res = true;
  end;
  
  CalculatedChargeType = res;
  return;
end;

procedure SetupInvoiceRowAndAdd(var record IVVc IVr,string item,string itemname,val quant,val price,val reb,Integer chargetype)
begin
  row IVVc IVrw;
  string 255 inwarning,warning;
  Integer sernrf,rw;
  record IVVc IV2r;
  val bval;

  
  if (price>0 and nonblank(item)) then begin
    rw = MatRowCnt(IVr);
    ClearRow(IVr,IVrw,1);
    IVrw.ArtCode = item;
    IVrw.Quant = quant;
    IVrw.ChargeType = chargetype;
    MatRowPut(IVr,rw,IVrw);
    if (IVVc_PasteArtCode(IVr,rw,inwarning,warning,false,sernrf)) then begin    
      IVDchsum(IVr,rw);
    end;
    MatRowGet(IVr,rw,IVrw);
    IVrw.Price = price;
    if (reb>0) then begin
      IVrw.vRebate = reb;
    end else begin
      IVrw.vRebate = bval;//should it be like that? what about discount matrix?
    end;
    MatRowPut(IVr,rw,IVrw);
    IVVc_PastePrice(IVr,IV2r,rw,warning);
    if (nonblank(itemname)) then begin
      MatRowGet(IVr,rw,IVrw);
      IVrw.Spec = itemname;
      MatRowPut(IVr,rw,IVrw);
    end;
  end;

  return;
end;
procedure AddInterestCalc(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr)
begin

  SetupInvoiceRowAndAdd(IVr,CMb.RateItem,"",1,GetRateAmount2(CredManr,CredManr.IntRate),0,kChargeTypeInterest);

  return;
end;

procedure AddInterest(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr)
begin

  SetupInvoiceRowAndAdd(IVr,CMb.RateItem,"",1,GetRateAmount(CredManr,CredManr.IntRate),0,kChargeTypeInterest);

  return;
end;

procedure AddPlannedFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer type)
begin
  Integer i,rwcnt;
  row CredManVc CredManrw;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if ((type==kPlannedFeesMonthly and MonthlyChargeType(CredManrw.ChargeType)) or 
        (type==kPlannedFeesOneTime and MonthlyChargeType(CredManrw.ChargeType)==false)) then begin
      if (CalculatedChargeType(CredManrw.ChargeType)) then begin
        SetupInvoiceRowAndAdd(IVr,CredManrw.ArtCode,CredManrw.Comment,1,GetRateAmount(CredManr,CredManrw.vRebate),0,kChargeTypePlannedFees);
      end else begin
        SetupInvoiceRowAndAdd(IVr,CredManrw.ArtCode,CredManrw.Comment,CredManrw.Quant,CredManrw.Price,CredManrw.vRebate,kChargeTypePlannedFees);
      end;
    end;
  end;
  
  return;
end;

procedure AddPlannedFeesCalc(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer type)
begin
  Integer i,rwcnt;
  row CredManVc CredManrw;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if ((type==kPlannedFeesMonthly and MonthlyChargeType(CredManrw.ChargeType)) or 
        (type==kPlannedFeesOneTime and MonthlyChargeType(CredManrw.ChargeType)==false)) then begin
      if (CalculatedChargeType(CredManrw.ChargeType)) then begin
        SetupInvoiceRowAndAdd(IVr,CredManrw.ArtCode,CredManrw.Comment,1,GetRateAmount2(CredManr,CredManrw.vRebate),0,kChargeTypePlannedFees);
      end else begin
        SetupInvoiceRowAndAdd(IVr,CredManrw.ArtCode,CredManrw.Comment,CredManrw.Quant,CredManrw.Price,CredManrw.vRebate,kChargeTypePlannedFees);
      end;
    end;
  end;
  return;
end;

procedure AddDepositSum(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr)
begin
  
  SetupInvoiceRowAndAdd(IVr,CMb.DepositItem,"",1,CredManr.DepositSum,0,kChargeTypeDeposit);

  return;
end;
procedure AddLateFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer latedays,val lateamount)
begin
  val laterate;
  
  if (lateamount>0) then begin
    SetupInvoiceRowAndAdd(IVr,CMb.LateFeeItem,"",1,0,0,kChargeTypeLateFees);
    SetupInvoiceRowAndAdd(IVr,CMb.LateRateItem,"",1,lateamount,0,kChargeTypeLateFees);
  end;

  return;
end;

procedure AddInstalment(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Boolean linearf)
begin
  
  if (linearf) then begin
    SetupInvoiceRowAndAdd(IVr,CMb.InstalmentItem,"",1,(CredManr.InvSum4-CredManr.DepositSum)/CredManr.InstalmentMonths,0,kChargeTypeInstalment);
  end else begin
    SetupInvoiceRowAndAdd(IVr,CMb.InstalmentItem,"",1,CredManr.InvSum4,0,kChargeTypeInstalment);
  end;
  return;
end;

procedure GetLatePaymentPlan(record CredHistVc CredHistr,Date sd,Date ed,var array val amounts)
begin
  Date tempsd;
  record CredHistVc CredPayr;//CredPayr - same credhistvc register, just for payments
  Integer i,daydiff;
  Boolean TrHs;
  val paysum;
  
  paysum = CredHistr.Sum;
  tempsd = sd;
  if (tempsd<=CredHistr.PayDate) then begin
    tempsd = AddDay(CredHistr.PayDate,1);
  end;
  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate>CredHistr.PayDate) then begin
        if (CredPayr.TransDate>sd and CredPayr.TransDate<=ed) then begin
          daydiff = DateDiff(CredPayr.TransDate,tempsd);//or DateDiff2 to get daydiff+1 days
          for (i=0;i<daydiff;i=i+1) begin
            amounts[amounts.length] = paysum;
          end;
        end;
        if (CredPayr.TransDate>ed) then begin//no need to continue for later payments
          TrHs = false;
        end;
        tempsd = CredPayr.TransDate;
      end;
      paysum = paysum - CredPayr.Sum;
    end;
  end;
  if (paysum>0 and tempsd<ed) then begin
    daydiff = DateDiff(ed,tempsd);
    for (i=0;i<daydiff;i=i+1) begin
      amounts[amounts.length] = paysum;
    end;
  end;

  return;
end;

procedure GetOverdueInvoices(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  array val amounts;
  val latefee;
  Integer i;

  //we should go through the history and check for late payments
  TrHs = true;
  CredHistr.ArtCode = CMb.RateItem;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=CMb.RateItem or CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      //Construct an array of days with amount that is over due starting with the first day of period
      GetLatePaymentPlan(CredHistr,AddDay(prevtd,1),invdate,amounts);
      for (i=0;i<amounts.length;i=i+1) begin
        latefee = latefee + (amounts[i]*(CredManr.OverduePercentage/100));
      end;
    end;
  end;

  lateamount = latefee;

  return;
end;

updating procedure CreateMonthlyLoanInvoice(record CredManVc CredManr,Date invdate,Date prevtd,Boolean firstf,Boolean lastf,Boolean linearf)
begin
  record CredManSetBlock CMb;
  Integer latedays;
  val lateamount;
  record IVVc IVr;

  BlockLoad(CMb);

  SetupLoanInvoice(CredManr,CMb,IVr,invdate);

  if (firstf) then begin
    AddInterestCalc(CredManr,CMb,IVr);
    AddDepositSum(CredManr,CMb,IVr);
    AddPlannedFeesCalc(CredManr,CMb,IVr,kPlannedFeesMonthly);
  end else begin
    AddInterest(CredManr,CMb,IVr);
    AddPlannedFees(CredManr,CMb,IVr,kPlannedFeesMonthly);
    GetOverdueInvoices(CredManr,CMb,invdate,prevtd,latedays,lateamount);
    AddLateFees(CredManr,CMb,IVr,latedays,lateamount);
  end;
  if (lastf or linearf) then begin
    AddInstalment(CredManr,CMb,IVr,linearf);
  end;

  if (MatRowCnt(IVr)>0) then begin
    IVr.OKFlag = 1;
    RecordInsert(IVr,true);
  end;

  return;
end;

procedure MergeItemsInInvoice(var record IVVc IVr)
begin
  Integer i,rwcnt,chargetype;
  row IVVc IVrw;
  vector val vRows;
  array string 255 arr;
  val quant,reb;
  Longint pos;
  string 255 index,tstr,item;
  
  rwcnt = MatRowCnt(IVr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(IVr,i,IVrw);
    index = IVrw.ArtCode & ":" & IVrw.Quant & ":" & IVrw.vRebate & ":" & IVrw.ChargeType;
    vRows[index] = vRows[index] + IVrw.Price;
    MatRowDelete(IVr,i);
  end;
  GetVectorTags(vRows,arr);
  for (i=0;i<arr.length;i=i+1) begin
    pos = -1;
    GetNextSubstring(arr[i],pos,":",item);
    GetNextSubstring(arr[i],pos,":",tstr);
    quant = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    reb = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    chargetype = StringToInt(tstr);
    SetupInvoiceRowAndAdd(IVr,item,"",quant,vRows[arr[i]],reb,chargetype);
  end;

  return;
end;

updating procedure CreateInitialLoanInvoice(record CredManVc CredManr)
begin
  record CredManSetBlock CMb;
  Integer latedays;
  val lateamount;
  record IVVc IVr;

  BlockLoad(CMb);

  SetupLoanInvoice(CredManr,CMb,IVr,CredManr.startDate);

  AddPlannedFees(CredManr,CMb,IVr,kPlannedFeesOneTime);
  MergeItemsInInvoice(IVr);

  if (MatRowCnt(IVr)>0) then begin
    IVr.OKFlag = 1;
    RecordInsert(IVr,true);
  end;

  return;
end;


procedure GetLastAgreementInvoice(record CredManVc CredManr,var Date sd,var Boolean firstf)
begin
  record CredHistVc CredHistr;
  
//is it unlikely that we'll have first invoice without monthly invoice? lets assume in first version that it is
  CredHistr.CustCode = CredManr.CustCode;
  CredHistr.RecordType = kCredHistRecTypeInvoice;
  if (ReadLastKey("CustTypeDate",CredHistr,2,true)) begin
    sd = CredHistr.TransDate;
  end else begin
    firstf = true;
  end;

  return;
end;

function Boolean GetNextInvoicableDate(var Date td,var Date prevtd,Date ed,record CredManVc CredManr)
begin
  Boolean res;
  
  prevtd = td;
  td = AddMonth(td,1);
  td.Day = DaysInMonth(td.Year,td.Month);
  if (td<=ed and td<=CredManr.endDate) begin //deal with all the other invoices
    res = true;
  end;

  GetNextInvoicableDate = res;
  return;
end;

updating procedure CreateSingleBulletTypeInvoice(record CredManVc CredManr,Date ed,Boolean linearf)
begin
  Date td,prevtd;
  Boolean firstf;
  
  GetLastAgreementInvoice(CredManr,td,firstf);
  if (firstf and ed>=CredManr.startDate) then begin//Deal with initial invoice
    CreateInitialLoanInvoice(CredManr);
  end;
  if (blank(td)) then begin
    td = CredManr.startDate;
  end;
  if (td<CredManr.FirstInvDate and ed>=CredManr.FirstInvDate) then begin//deal with first monthly invoice
    td = CredManr.FirstInvDate;
    CreateMonthlyLoanInvoice(CredManr,td,td,true,(td==CredManr.endDate),linearf);
  end;
  
  while (GetNextInvoicableDate(td,prevtd,ed,CredManr)) begin
    CreateMonthlyLoanInvoice(CredManr,td,prevtd,false,(td==CredManr.endDate),linearf);
  end;
  
  return;
end;

updating procedure CreateSingleFactoringTypeInvoice(record CredManVc CredManr,Date ed)
begin 
  record CredManSetBlock CMb;
  record IVVc IVr;
  Boolean firstf;
  Date td;

  GetLastAgreementInvoice(CredManr,td,firstf);
  if (firstf and CredManr.FirstInvDate<=ed) then begin
    BlockLoad(CMb);
    SetupLoanInvoice(CredManr,CMb,IVr,CredManr.FirstInvDate);

    AddInterestCalc(CredManr,CMb,IVr);
    AddPlannedFees(CredManr,CMb,IVr,kPlannedFeesMonthly);
    AddPlannedFees(CredManr,CMb,IVr,kPlannedFeesOneTime);
    AddInstalment(CredManr,CMb,IVr,false);
    if (MatRowCnt(IVr)>0) then begin
      IVr.OKFlag = 1;
      RecordInsert(IVr,true);
    end;
  end;

  return;
end;

global
updating procedure CreateSingleAgreementInvoice(record CredManVc CredManr,Date ed)
begin

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    switch (CredManr.InstalmentType) begin
      //should be other types here as well
      case 0://Annuity

      case 1://Linear
      case 2://Linear with Service Fee
        CreateSingleBulletTypeInvoice(CredManr,ed,true);
      case 3://Bullet
        CreateSingleBulletTypeInvoice(CredManr,ed,false);
      case 4://Factoring
        CreateSingleFactoringTypeInvoice(CredManr,ed);
      //case 5://Payment Guarantee

      otherwise CreateSingleBulletTypeInvoice(CredManr,ed,false);
    end;
  end;

  return;
end;
updating procedure CreateCredHist(Longint recnr,Integer chargetype,string custcode,val sum,Integer rectype,string item,Date duedate,Longint agreementnr,Date invdate,var Longint histnr)
begin
  record CredHistVc CredHistr;
  
  histnr = -1;

  RecordNew(CredHistr);
  CredHistr.SerNr = NextSerNr("CredHistVc",CurrentDate,-1,false,"");
  CredHistr.TransDate = invdate;
  CredHistr.RecordNr = recnr;
  CredHistr.ChargeType = chargetype;
  CredHistr.CustCode = custcode;
  CredHistr.RecordType = rectype;
  CredHistr.ArtCode = item;
  CredHistr.RecordType = rectype;
  CredHistr.PayDate = duedate;
  CredHistr.CredManNr = agreementnr;
  CredHistr.Sum = sum;
  if (RecordInsert(CredHistr,true)) then begin
    histnr = CredHistr.SerNr;
  end;

  return;
end;

updating procedure RemoveCredHist(Longint recnr,Integer rectype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  TrHs = true;
  CredHistr.RecordNr = recnr;
  CredHistr.RecordType = rectype;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordType!=rectype or CredHistr.RecordNr!=recnr) then begin
      TrHs = false;
    end else begin
      RecordRemove(CredHistr);
      StepBack(CredHistr);
    end;
  end;

  return;
end;

function val CalculateRowSumWithVAT(record IVVc IVr,row IVVc IVrw)
begin
  val res;

//first version is just row sum. We should include VAT to match with payments
  res = IVrw.Sum;

  CalculateRowSumWithVAT = res;
  return;
end;

global
updating procedure UpdateCredHistInvoice(var record IVVc IVr,record IVVc IV2r)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  Longint histnr;

  if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
    RemoveCredHist(IVr.SerNr,kCredHistRecTypeInvoice);
  end;
  
  if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ChargeType>0) then begin
        CreateCredHist(IVr.SerNr,IVrw.ChargeType,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),kCredHistRecTypeInvoice,IVrw.ArtCode,IVr.PayDate,IVr.CustCredManNr,IVr.InvDate,histnr);
        IVrw.CredHistNr = histnr;
        MatRowPut(IVr,i,IVrw);
      end;
    end;
  end;

  return;
end;
